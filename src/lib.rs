use std::str::FromStr;

use num_derive::{FromPrimitive, ToPrimitive};
use rust_bert::{
    pipelines::{
        pos_tagging::POSConfig,
        token_classification::{Token, TokenClassificationModel},
    },
    RustBertError,
};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Part-of-speech tagging model.
pub struct POSModel {
    pub model: TokenClassificationModel,
}

/// Iterator over the result of a POSModel prediction.
/// Implements `Iter<Item = Result<POSToken, PartOfSpeechError>>`.
pub type POSTokenResultIter = std::iter::Map<
    std::vec::IntoIter<Token>,
    fn(Token) -> Result<POSToken, <POSToken as TryFrom<Token>>::Error>,
>;

impl POSModel {
    pub fn try_default() -> Result<Self, RustBertError> {
        let model = TokenClassificationModel::new(POSConfig::default().into())?;
        Ok(Self { model })
    }

    /// Predict [`POSToken`]s for `input`.
    pub fn predict(&self, input: &str) -> POSTokenResultIter {
        let mut token_vecs = self.model.predict(&[input], true, false);
        debug_assert_eq!(1, token_vecs.len());
        token_vecs
            .pop()
            .unwrap()
            .into_iter()
            .map(POSToken::try_from)
    }
}

// SAFETY: We only read `model`, and do not alias any pointers.
unsafe impl Send for POSModel {}
unsafe impl Sync for POSModel {}

/// Parsed Token generated by a `TokenClassificationModel`
/// Adapted from `rust-bert`'s `Token` struct.
#[derive(Clone, Debug, Default, PartialEq, PartialOrd)]
#[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
pub struct POSToken {
    /// String representation of the Token
    pub word: String,
    /// Confidence score
    pub score: f64,
    /// Part-of-speech tag
    pub tag: PartOfSpeech,
    /// Label index
    pub label_index: i64,
    /// Token position index
    pub index: u16,
    /// Token word position index
    pub word_index: u16,
    /// Token offset beginning (in unicode points) relative to the input string
    pub offset_begin: u32,
    /// Token offset end (in unicode points) relative to the input string
    pub offset_end: u32,
}

impl POSToken {
    pub fn tag_with_confidence(&self, confidence: f64) -> Option<PartOfSpeech> {
        (self.score > confidence).then_some(self.tag)
    }
}

impl TryFrom<Token> for POSToken {
    type Error = PartOfSpeechError;

    fn try_from(value: Token) -> Result<Self, Self::Error> {
        let Token {
            text,
            score,
            label,
            label_index,
            sentence: _inaccurate_so_useless,
            index,
            word_index,
            offset,
            mask: _we_do_not_care,
        } = value;
        match offset {
            Some(offset) => Ok(Self {
                word: text,
                score,
                tag: label.parse()?,
                label_index,
                index,
                word_index,
                offset_begin: offset.begin,
                offset_end: offset.end,
            }),
            None => Err(PartOfSpeechError::MissingOffset(text)),
        }
    }
}

/// Enum representing part-of-speech labels of MobileBERT, from
/// <https://huggingface.co/mrm8488/mobilebert-finetuned-pos/resolve/main/config.json>.
// NOTE: ChatGPT generated the docstrings, so they may be inaccurate.
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[cfg_attr(feature = "serde", derive(Deserialize, Serialize))]
#[cfg_attr(feature = "num", derive(FromPrimitive, ToPrimitive))]
pub enum PartOfSpeech {
    /// Coordinating conjunction
    CC = 0,
    /// Cardinal number
    CD = 1,
    /// Determiner
    DT = 2,
    /// Existential there
    EX = 3,
    /// Foreign word
    FW = 4,
    /// Preposition or subordinating conjunction
    IN = 5,
    /// Adjective
    JJ = 6,
    /// Adjective, comparative
    JJR = 7,
    /// Adjective, superlative
    JJS = 8,
    /// Modal
    MD = 9,
    /// Noun, singular or mass
    NN = 10,
    /// Proper noun, singular
    NNP = 11,
    /// Proper noun, plural
    NNPS = 12,
    /// Noun, plural
    NNS = 13,
    /// Other (not a part of speech)
    #[default]
    O = 14,
    /// Predeterminer
    PDT = 15,
    /// Possessive ending
    POS = 16,
    /// Personal pronoun
    PRP = 17,
    /// Adverb
    RB = 18,
    /// Adverb, comparative
    RBR = 19,
    /// Adverb, superlative
    RBS = 20,
    /// Particle
    RP = 21,
    /// Symbol
    SYM = 22,
    /// to
    TO = 23,
    /// Interjection
    UH = 24,
    /// Verb, base form
    VB = 25,
    /// Verb, past tense
    VBD = 26,
    /// Verb, gerund or present participle
    VBG = 27,
    /// Verb, past participle
    VBN = 28,
    /// Verb, non-3rd person singular present
    VBP = 29,
    /// Verb, 3rd person singular present
    VBZ = 30,
    /// Wh-determiner
    WDT = 31,
    /// Wh-pronoun
    WP = 32,
    /// Wh-adverb
    WRB = 33,
}

pub const N_PART_OF_SPEECH: u8 = 34;

impl FromStr for PartOfSpeech {
    type Err = PartOfSpeechError;

    fn from_str(input: &str) -> Result<Self, Self::Err> {
        match input {
            "CC" => Ok(Self::CC),
            "CD" => Ok(Self::CD),
            "DT" => Ok(Self::DT),
            "EX" => Ok(Self::EX),
            "FW" => Ok(Self::FW),
            "IN" => Ok(Self::IN),
            "JJ" => Ok(Self::JJ),
            "JJR" => Ok(Self::JJR),
            "JJS" => Ok(Self::JJS),
            "MD" => Ok(Self::MD),
            "NN" => Ok(Self::NN),
            "NNP" => Ok(Self::NNP),
            "NNPS" => Ok(Self::NNPS),
            "NNS" => Ok(Self::NNS),
            "O" => Ok(Self::O),
            "PDT" => Ok(Self::PDT),
            "POS" => Ok(Self::POS),
            "PRP" => Ok(Self::PRP),
            "RB" => Ok(Self::RB),
            "RBR" => Ok(Self::RBR),
            "RBS" => Ok(Self::RBS),
            "RP" => Ok(Self::RP),
            "SYM" => Ok(Self::SYM),
            "TO" => Ok(Self::TO),
            "UH" => Ok(Self::UH),
            "VB" => Ok(Self::VB),
            "VBD" => Ok(Self::VBD),
            "VBG" => Ok(Self::VBG),
            "VBN" => Ok(Self::VBN),
            "VBP" => Ok(Self::VBP),
            "VBZ" => Ok(Self::VBZ),
            "WDT" => Ok(Self::WDT),
            "WP" => Ok(Self::WP),
            "WRB" => Ok(Self::WRB),
            _ => Err(PartOfSpeechError::UnknownLabel(input.into())),
        }
    }
}

#[derive(Clone, Debug, Error)]
pub enum PartOfSpeechError {
    #[error("Unknown part of speech label `{0}`")]
    UnknownLabel(String),
    #[error("Token `{0}` without offset is ignored")]
    MissingOffset(String),
}

#[cfg(test)]
mod tests;
